sha256 散列函数，将一长串数据讲过hash散列，压缩成摘要，使数据量变小格式固定下来


5g融合消息：10开发，2sms 3 vedio 5 5g消息 4测试 2 

业务需求评审：需求出原型，后台依据需求做设计，做评审
服务框架搭建：传统聚合项目依据业务类型拆分，按模块实现功能，降低与业务之间的耦合性，提高代码的复用率


thread实现的三种方式

thread runnable executor lamdbar表达式


yeild() 让出cpu一下

join() 线程顺序执行 1，2 ，3

Thread.sleep


# 线程状态

       NEW REDAY RUNNING TEMINATIED
       
       LockSupport.park()       LockSupport.unpark();
       o.wait()                     o.notify()
       o.yield()                    o.notifyall()
       
       
  interrupt()   打断线程，用的少    捕获interruptException 进行处理
  
  
  claddloader 一个.class是单例的
  
  
  synchronized 公平锁，可重入锁  通过super调用父类方法的时候synchronized可以实现重入
  
  synchronized(this)锁定的是当前对象
  
  1.8优化  分片锁，性能提高
  
  
  # sync 锁升级 hotstop
  synchronized（object）  不可以用常量Sting常量，Long,Integer，容易造成死锁，数据存放在常量池中可能被重复引用
  markword 记录线程id(偏向锁)  
  如果有线程征用 升级为自旋锁，
  默认10次，
  升级为重量级锁，等待cpu
        //** 用户态，不经过cpu，效率高
 
 #自旋锁和重量级锁使用场景
  执行时间长，用重量级别锁
  执行时间段，线程数量少，用cas自旋锁
  
# spring框架

ioc 控制反转 bean容器管理对象
apo 方法增强
  
#volatile

    线程之间可见性
        - Mesi
        - cpu缓存一致性
    禁止指令冲排序
        -dcl单例
        -double check lock
        -loadFence 读屏障  cpu原语
        -storefance 写屏障 cpu原语
        
## new 一个对象 分三步 超高状态情况下，指令重排序，2 3 步骤不一定按顺序只执行
1.申请内存
2.属性初始化
3.只想栈中引用

#CAS
final unsafe:sun.misc包下（jdk版本有关1.8必须通过反射取用，11以后可以直接使用）
直接操作内存，直接生成实例，直接操作类或实例变量，cas相关； 
使用： 直接调用getUnsafe()单例
cas 实现方法：weakCompareAndSetObject

compareAndSet
 ～ cas(V,expected,newValue)
    V：当前值
    expected:期望值
    newValue:新值
 ～cup原语    
 
##### ABA问题
    基础类型无所谓，引用类型增加version 女朋友-分手-女朋友
    
递增
1.synchronized

2.AtomicInteger
    getIncrementAddSet
3.LongAdder     分片锁，线程多情况下效率高 
    increment
 
 
 
## guava  RateLimiter       api限流

AQS 底层

LockSupport     unsafe
    park(Thread)  指定thread   
    unpark(Thread)
  unpark 可以在park之前执行
  notify 不可以在 wait之前行（否则不会生效˜）